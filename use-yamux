// vsock-client
mod trans_client;
use env_logger;
// use std::path::PathBuf;
use trans_client::{TransClient, ClientTarget};

const DATA_SIZE: usize =  10 * 1024 * 1024; // 10 MB
const DEFAULT_SERVER_CID: u32 = 103;       // 默认2， qemu用103， pvm用3
const DEFAULT_SERVER_PORT: u32 = 1234;


#[tokio::main]
async fn main() {
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info")).init();

    // let target = ClientTarget::Unix(PathBuf::from("/tmp/yamux.sock"));
    let target = ClientTarget::Vsock { cid: DEFAULT_SERVER_CID, port: DEFAULT_SERVER_PORT };
    // let target = ClientTarget::Tcp("127.0.0.1:1234".parse().unwrap());

    let client = TransClient::new(target);

    // 发送指定大小的数据
    log::info!("Sending {} KB of data...", DATA_SIZE / 1024);
    let data: Vec<u8> = vec![0xAB; DATA_SIZE];
    client.send_message(&data).await;

}

// trans_client
use futures::future::poll_fn;
use futures::io::{AsyncRead, AsyncWrite};
use futures::{AsyncReadExt, AsyncWriteExt};
use std::net::SocketAddr;
use std::path::PathBuf;
use std::time::Instant;
use tokio::net::{TcpStream, UnixStream};
use tokio_util::compat::TokioAsyncReadCompatExt;
use tokio_vsock::{VsockAddr, VsockStream};
use yamux::{Config, Connection, Mode};
use log::*;

#[allow(dead_code)]
#[derive(Debug)]
pub enum ClientTarget {
    Unix(PathBuf),
    Tcp(SocketAddr),
    Vsock { cid: u32, port: u32 },
}

pub struct TransClient {
    target: ClientTarget,
}

impl TransClient {
    pub fn new(target: ClientTarget) -> Self {
        Self { target }
    }

    pub async fn send_message(&self, message: &[u8]) {
        info!("Connecting to target: {:?}", self.target);
        match &self.target {
            ClientTarget::Unix(path) => {
                let stream = UnixStream::connect(path)
                    .await
                    .expect("Failed to connect Unix Socket");
                info!("Unix socket connected.");
                self.process_stream(stream.compat(), message).await;
            }
            ClientTarget::Tcp(addr) => {
                let stream = TcpStream::connect(addr)
                    .await
                    .expect("Failed to connect TCP Socket");
                info!("TCP socket connected.");
                self.process_stream(stream.compat(), message).await;
            }
            ClientTarget::Vsock { cid, port } => {
                let stream = VsockStream::connect(VsockAddr::new(*cid, *port))
                    .await
                    .expect("Failed to connect Vsock Socket");
                info!("Vsock socket connected.");
                self.process_stream(stream.compat(), message).await;
            }
        }
    }

    async fn process_stream<T>(&self, stream: T, message: &[u8])
    where
        T: AsyncRead + AsyncWrite + Unpin + Send + 'static,
    {
        // Initialize Yamux connection
        let config = Config::default();
        let mut conn = Connection::new(stream, config, Mode::Client);

        // Open a logical stream
        info!("Opening Yamux stream...");
        let mut yamux_stream = poll_fn(|cx| conn.poll_new_outbound(cx))
            .await
            .expect("Failed to open stream");
        info!("Yamux stream opened.");

        // Spawn the connection driver
        tokio::spawn(async move {
            loop {
                // poll_next_inbound will continuously read underlying data and parse Yamux frames
                // Connection 提供的 API 是低级的 Poll 接口（主要为了兼容 Stream trait 或者底层的 Future 机制）。
                // poll_fn 把它包装成一个可以在 async 块里 .await 的 Future。
                match poll_fn(|cx: &mut std::task::Context<'_>| conn.poll_next_inbound(cx)).await {
                    Some(Ok(_)) => {
                        // We don't expect inbound streams in this example, but we must drive the connection
                    }
                    Some(Err(e)) => {
                        error!("Connection error: {}", e);
                        break;
                    }
                    None => break,
                }
            }
            info!("Connection closed");
        });

        // Send message and test performance
        let start = Instant::now();
        yamux_stream
            .write_all(message)
            .await
            .expect("Failed to send message");
        yamux_stream.close().await.expect("Failed to close stream"); // Close the write end to notify the Server that data sending is complete
        let elapsed = start.elapsed();
        let speed = (message.len() as f64 / 1024.0) / elapsed.as_secs_f64();
        info!("=== Send Complete ===");
        info!("Total sent: {} KB", message.len() / 1024);
        info!("Time: {:.2} seconds", elapsed.as_secs_f64());
        info!("Speed: {:.2} KB/s", speed);
        info!("");
        info!("");

        // Read reply
        let start = Instant::now();
        let mut buf = Vec::new();
        yamux_stream
            .read_to_end(&mut buf)
            .await
            .expect("Failed to read reply");
        let elapsed = start.elapsed();
        let speed = (buf.len() as f64 / 1024.0) / elapsed.as_secs_f64();
        info!("=== Receive Complete ===");
        info!("Total received: {} KB", buf.len() / 1024);
        info!("Time: {:.2} seconds", elapsed.as_secs_f64());
        info!("Speed: {:.2} KB/s", speed);


    }
}


// vsock-server
mod trans_server;

// use std::path::PathBuf;
use crate::trans_server::{ServerTarget, TransServer};
use tokio_vsock::VMADDR_CID_ANY;

const DATA_SIZE: usize =  200 * 1024; // 2 MB


#[tokio::main]
async fn main() -> std::io::Result<()> {
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info")).init();
    // let target = ServerTarget::Unix(PathBuf::from("/tmp/yamux.sock"));
    let target = ServerTarget::Vsock { cid: VMADDR_CID_ANY, port: 1234 };
    // let target = ServerTarget::Tcp("127.0.0.1:1234".parse().unwrap());

    let server = TransServer::new(target);
    server.run().await;

    Ok(())  
}

// trans_server
use futures::future::poll_fn;
use futures::io::{AsyncRead, AsyncWrite};
use futures::{AsyncReadExt, AsyncWriteExt};
use std::net::SocketAddr;
use std::path::PathBuf;
use std::time::Instant;
use tokio::net::{TcpListener, UnixListener};
use tokio_util::compat::TokioAsyncReadCompatExt;
use tokio_vsock::{VsockAddr, VsockListener};
use yamux::{Config, Connection, Mode};
use log::*;

use crate::DATA_SIZE;

#[allow(dead_code)]
#[derive(Debug)]
pub enum ServerTarget {
    Unix(PathBuf),
    Tcp(SocketAddr),
    Vsock { cid: u32, port: u32 },
}

pub struct TransServer {
    target: ServerTarget,
}

impl TransServer {
    pub fn new(target: ServerTarget) -> Self {
        Self { target }
    }

    pub async fn run(&self) {
        match &self.target {
            ServerTarget::Unix(path) => {
                if path.exists() {
                    let _ = std::fs::remove_file(path);
                }
                let listener = UnixListener::bind(path).expect("Failed to bind Unix Socket");
                info!("Server listening on Unix Socket {:?}", path);
                loop {
                    let (stream, _) = listener.accept().await.expect("Failed to accept");
                    info!("Accepted Unix connection");
                    tokio::spawn(Self::handle_connection(stream.compat()));
                    info!("Spawned task to handle Unix connection");
                }
            }
            ServerTarget::Tcp(addr) => {
                let listener = TcpListener::bind(addr).await.expect("Failed to bind TCP Socket");
                info!("Server listening on TCP {:?}", addr);
                loop {
                    let (stream, peer) = listener.accept().await.expect("Failed to accept");
                    info!("Accepted TCP connection from {:?}", peer);
                    tokio::spawn(Self::handle_connection(stream.compat()));
                }
            }
            ServerTarget::Vsock { cid, port } => {
                let listener = VsockListener::bind(VsockAddr::new(*cid, *port)).expect("Failed to bind Vsock Socket");
                info!("Server listening on Vsock CID:{} Port:{}", cid, port);
                
                    let (stream, addr) = listener.accept().await.expect("Failed to accept");
                    info!("Accepted Vsock connection from {:?}", addr);
                    Self::handle_connection(stream.compat()).await;
                    info!("Spawned task to handle Vsock connection");
                
            }
        }
    }

    /// Handles a new incoming connection using the Yamux protocol.
    /// This function drives the Yamux connection and handles logical streams spawned from it.
    pub async fn handle_connection<T>(stream: T)
    where
        T: AsyncRead + AsyncWrite + Unpin + Send + 'static,
    {
        info!("Starting Yamux handshake...");
        let config = Config::default();
        let mut conn = Connection::new(stream, config, Mode::Server);

        loop {
            // Poll for new inbound logical streams created by the client
            match poll_fn(|cx| conn.poll_next_inbound(cx)).await {
                Some(Ok(stream)) => {
                    // Spawn a new task to handle this specific logical stream independently
                    tokio::spawn(async move {
                        if let Err(e) = Self::handle_stream(stream).await {
                            error!("[Yamux] Stream error: {}", e);
                        }
                    });
                }
                Some(Err(e)) => {
                    error!("Connection error: {}", e);
                    break;
                }
                None => {
                    info!("Connection closed by remote");
                    break;
                }
            }
            info!("Yamux connection polling for new inbound streams...");
        }

        info!("Yamux connection handler exiting");
    }

    /// Handles a single logical Yamux stream.
    /// Reads a message and sends an acknowledgment back.
    async fn handle_stream<S>(mut stream: S) -> std::io::Result<()>
    where
        S: AsyncRead + AsyncWrite + Unpin + Send + 'static,
    {
        info!("[Yamux] New stream opened");
        let mut buf = Vec::new();

        // Read all data until EOF
        let start = Instant::now();
        let n = stream.read_to_end(&mut buf).await.expect("Failed to read data");
        let elapsed = start.elapsed();
        let speed = (n as f64 / 1024.0) / elapsed.as_secs_f64();
        info!("=== Receive Complete ===");
        info!("Total received: {} KB", n / 1024);
        info!("Time: {:.2} seconds", elapsed.as_secs_f64());
        info!("Speed: {:.2} KB/s", speed);
        info!("");
        info!("");

        if n == 0 {
            info!("[Yamux] Stream closed empty");
            return Ok(());
        }

        // Send reply
        let start = Instant::now();
        let reply: Vec<u8> = vec![0xAB; DATA_SIZE];
        stream.write_all(&reply).await?;
        stream.flush().await?;
        stream.close().await?;
        let elapsed = start.elapsed();
        let speed = (DATA_SIZE as f64 / 1024.0) / elapsed.as_secs_f64();
        info!("=== Send Complete ===");
        info!("Total sent: {} KB", DATA_SIZE / 1024);
        info!("Time: {:.2} seconds", elapsed.as_secs_f64());
        info!("Speed: {:.2} KB/s", speed);
        info!("");
        info!("");

        info!("[Yamux] Reply sent and stream closed");

        Ok(())
        // // Force exit after sending reply (for testing purposes)
        // std::process::exit(0);
    }
}

